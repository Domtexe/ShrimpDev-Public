
# ============================================================
# logic_actions.py - FULL RESTORE VERSION (R1514)
# Kompatibel mit:
# - config_loader.py (INI)
# - ui_leds (Syntax Only for PY)
# - Intake (Name/Endung ohne Punkt)
# ============================================================

from __future__ import annotations

import os
import re
import ast
from datetime import datetime
from tkinter import messagebox
import tkinter as tk




def log_debug(msg: str):
    from datetime import datetime
    from pathlib import Path
    try:
        root = Path(__file__).resolve().parent.parent
        from modules.config_loader import ConfigLoader
        cfg = ConfigLoader(root / "ShrimpDev.ini")

        do_log = cfg.get_logging_bool("gui_debug", True)
        use_ts = cfg.get_logging_bool("timestamps", True)

        if not do_log:
            return

        if use_ts:
            msg = f"{datetime.now().isoformat()} " + msg

        log_path = root / "debug_output.txt"
        # R2045: Logrotation
        try:
            max_size_mb = int(cfg._config.get("logging", "max_size_mb", fallback="5"))
        except Exception:
            max_size_mb = 5
        try:
            rotations = int(cfg._config.get("logging", "rotations", fallback="5"))
        except Exception:
            rotations = 5
        if max_size_mb < 1:
            max_size_mb = 1
        if rotations < 1:
            rotations = 1

        def _rotate_log(path, max_mb, max_rot):
            try:
                max_bytes = max_mb * 1024 * 1024
                if not path.exists() or path.stat().st_size <= max_bytes:
                    return
                oldest = Path(str(path) + f".{max_rot}")
                if oldest.exists():
                    oldest.unlink()
                for idx in range(max_rot - 1, 0, -1):
                    src = Path(str(path) + f".{idx}")
                    if src.exists():
                        dst = Path(str(path) + f".{idx+1}")
                        src.rename(dst)
                backup_path = Path(str(path) + ".1")
                if path.exists():
                    path.rename(backup_path)
            except Exception:
                pass

        _rotate_log(log_path, max_size_mb, rotations)
        with open(log_path, "a", encoding="utf-8") as f:
            f.write(msg + "\n")
    except Exception:
        pass



def _get_intake(app):
    """
    Liefert das Intake-Textwidget (ScrolledText) oder None.
    """
    try:
        for attr in ("intake_text", "txt_intake", "txt_code"):
            w = getattr(app, attr, None)
            if w is not None:
                return w
    except Exception:
        pass
    return None


def _get_name_var(app):
    """
    Liefert die StringVar fuer den Dateinamen oder None.
    """
    try:
        import tkinter as tk  # lokaler Alias, falls noetig
        for attr in ("var_name", "name_var", "file_name_var"):
            v = getattr(app, attr, None)
            if isinstance(v, tk.StringVar):
                return v
    except Exception:
        pass
    return None


def _get_ext_var(app):
    """
    Liefert die StringVar fuer die Dateiendung oder None.
    """
    try:
        import tkinter as tk
        for attr in ("var_ext", "ext_var", "file_ext_var"):
            v = getattr(app, attr, None)
            if isinstance(v, tk.StringVar):
                return v
    except Exception:
        pass
    return None


def _status(app, msg: str) -> None:
    """
    R1832: Zentrale Statusausgabe fuer Intake-Aktionen.
    Versucht zuerst app.set_status, faellt dann auf _status-StringVar zurueck.
    """
    if app is None:
        return
    try:
        if hasattr(app, "set_status"):
            app.set_status(str(msg))
            return
    except Exception:
        pass
    try:
        var = getattr(app, "_status", None)
        if var is not None:
            try:
                var.set(str(msg))
                if hasattr(app, "update_idletasks"):
                    app.update_idletasks()
            except Exception:
                pass
    except Exception:
        pass




def _intake_syntax_check(app, for_save: bool = False) -> bool:
    """
    Syntax- und einfache Stil-Pruefung fuer den aktuellen Intake-Code.

    Rueckgabe:
        True  -> Syntaxfehler gefunden (z.B. Speichern blockieren)
        False -> kein Syntaxfehler
    """
    w = _get_intake(app)
    if w is None:
        return False

    try:
        source = w.get("1.0", "end-1c")
    except Exception:
        return False

    # Alte Markierung entfernen
    try:
        w.tag_delete("syntax_err")
    except Exception:
        pass

    # Endung ermitteln (.py / py / anderes)
    ext = ""
    try:
        v_ext = _get_ext_var(app)
    except Exception:
        v_ext = None
    if v_ext is not None:
        try:
            ext = (v_ext.get() or "").strip()
        except Exception:
            ext = ""
    ext = ext.lstrip(".").lower()

    # Nur Python pruefen; andere Sprachen bleiben unmarkiert
    if ext and ext != "py":
        return False

    if not source.strip():
        return False

    try:
        compile(source, "<intake>", "exec")
        if for_save:
            _status(app, "Syntax OK.")
        return False
    except SyntaxError as err:
        line = err.lineno or 1
        msg = err.msg or "Syntaxfehler"
        try:
            w.tag_configure("syntax_err", background="#FFCCCC", foreground="#000000")
            w.tag_add("syntax_err", f"{line}.0", f"{line}.end")
            w.see(f"{line}.0")
        except Exception:
            pass
        _status(app, f"Syntaxfehler in Zeile {line}: {msg}")
        return True
    except Exception as exc:
        try:
            _status(app, f"Fehler beim Syntax-Check: {exc}")
        except Exception:
            pass
        return False

def action_delete(app, *args, **kwargs):
    """Auto-generiert durch R1822: Platzhalter-Aktion fuer action_delete."""
    try:
        _status(app, "Aktion 'action_delete' ist noch nicht implementiert.")
    except Exception:
        try:
            print("[R1822] Aktion 'action_delete' aufgerufen, aber _status nicht verfuegbar.")
        except Exception:
            pass

# ------------------------------------------------------------

# ------------------------------------------------------------
# Erkennung (R1832)
# ------------------------------------------------------------
def action_guard_futurefix(app, *args, **kwargs):
    """Auto-generiert durch R1822: Platzhalter-Aktion fuer action_guard_futurefix."""
    try:
        _status(app, "Aktion 'action_guard_futurefix' ist noch nicht implementiert.")
    except Exception:
        try:
            print("[R1822] Aktion 'action_guard_futurefix' aufgerufen, aber _status nicht verfuegbar.")
        except Exception:
            pass

# ------------------------------------------------------------
# Auto-Placeholder (R1822) fuer action_guard_futurefix_safe
# ------------------------------------------------------------

def action_guard_futurefix_safe(app, *args, **kwargs):
    """Auto-generiert durch R1822: Platzhalter-Aktion fuer action_guard_futurefix_safe."""
    try:
        _status(app, "Aktion 'action_guard_futurefix_safe' ist noch nicht implementiert.")
    except Exception:
        try:
            print("[R1822] Aktion 'action_guard_futurefix_safe' aufgerufen, aber _status nicht verfuegbar.")
        except Exception:
            pass

# ------------------------------------------------------------
# Auto-Placeholder (R1822) fuer action_learning_journal
# ------------------------------------------------------------

def action_learning_journal(app, *args, **kwargs):
    """Auto-generiert durch R1822: Platzhalter-Aktion fuer action_learning_journal."""
    try:
        _status(app, "Aktion 'action_learning_journal' ist noch nicht implementiert.")
    except Exception:
        try:
            print("[R1822] Aktion 'action_learning_journal' aufgerufen, aber _status nicht verfuegbar.")
        except Exception:
            pass

# ------------------------------------------------------------
# Auto-Placeholder (R1822) fuer action_r9998
# ------------------------------------------------------------

def action_r9998(app, *args, **kwargs):
    """Auto-generiert durch R1822: Platzhalter-Aktion fuer action_r9998."""
    try:
        _status(app, "Aktion 'action_r9998' ist noch nicht implementiert.")
    except Exception:
        try:
            print("[R1822] Aktion 'action_r9998' aufgerufen, aber _status nicht verfuegbar.")
        except Exception:
            pass

# ------------------------------------------------------------
# Auto-Placeholder (R1822) fuer action_r9999
# ------------------------------------------------------------

def action_r9999(app, *args, **kwargs):
    """Auto-generiert durch R1822: Platzhalter-Aktion fuer action_r9999."""
    try:
        _status(app, "Aktion 'action_r9999' ist noch nicht implementiert.")
    except Exception:
        try:
            print("[R1822] Aktion 'action_r9999' aufgerufen, aber _status nicht verfuegbar.")
        except Exception:
            pass

# ------------------------------------------------------------
# Auto-Placeholder (R1822) fuer action_rename
# ------------------------------------------------------------

def action_rename(app, *args, **kwargs):
    """Auto-generiert durch R1822: Platzhalter-Aktion fuer action_rename."""
    try:
        _status(app, "Aktion 'action_rename' ist noch nicht implementiert.")
    except Exception:
        try:
            print("[R1822] Aktion 'action_rename' aufgerufen, aber _status nicht verfuegbar.")
        except Exception:
            pass

# ------------------------------------------------------------
# Auto-Placeholder (R1822) fuer action_run
# ------------------------------------------------------------
def action_tree_delete(app, *args, **kwargs):
    """Auto-generiert durch R1822: Platzhalter-Aktion fuer action_tree_delete."""
    try:
        _status(app, "Aktion 'action_tree_delete' ist noch nicht implementiert.")
    except Exception:
        try:
            print("[R1822] Aktion 'action_tree_delete' aufgerufen, aber _status nicht verfuegbar.")
        except Exception:
            pass

# ------------------------------------------------------------
# Auto-Placeholder (R1822) fuer action_tree_rename
# ------------------------------------------------------------




def action_tree_rename(app, *args, **kwargs):
    import os as _os

    try:
        from modules import module_runner_exec  # R2247
from modules import ui_project_tree as _uipt
        try:
            paths = _uipt.get_selected_paths(app)
        except Exception:
            paths = []
        if not paths:
            try:
                single = _uipt.get_selected_path(app)
            except Exception:
                single = None
            if single:
                paths = [single]
    except Exception:
        paths = []

    if not paths:
        try:
            _r1840_msg_info('Rename', 'Bitte zuerst eine oder mehrere Dateien im Tree markieren.')
        except Exception:
            pass
        return

    try:
        paths = sorted(dict.fromkeys(paths))
    except Exception:
        pass

    if len(paths) == 1:
        path = paths[0]
        folder = _os.path.dirname(path)
        old_name = _os.path.basename(path)
        try:
            new_name = _r1840_ask_string('Rename', 'Neuer Dateiname (ohne Pfad):', old_name)
        except Exception:
            new_name = None
        if not new_name:
            return
        new_name = str(new_name).strip()
        if not new_name:
            return
        new_path = _os.path.join(folder, new_name)
        if _os.path.exists(new_path):
            try:
                _r1840_msg_error('Rename', 'Es existiert bereits eine Datei mit diesem Namen.')
            except Exception:
                pass
            return
        try:
            _os.rename(path, new_path)
        except Exception as exc:
            try:
                _r1840_msg_error('Rename', 'Fehler beim Umbenennen: ' + repr(exc))
            except Exception:
                pass
            return
        try:
            from time import time as _time_now
            stack = _r1840_get_undo_stack(app)
            entry = {
                'action': 'rename',
                'old_path': path,
                'new_path': new_path,
                'time': _time_now(),
            }
            stack.append(entry)
        except Exception:
            pass
    else:
        first = paths[0]
        folder0 = _os.path.dirname(first)
        base0 = _os.path.splitext(_os.path.basename(first))[0]
        try:
            base = _r1840_ask_string('Mehrfach-Rename', 'Basisname fuer Mehrfach-Umbenennung (Index wird angehaengt):', base0)
        except Exception:
            base = None
        if not base:
            return
        base = str(base).strip()
        if not base:
            return
        try:
            from time import time as _time_now
        except Exception:
            def _time_now():
                import time as _t
                return _t.time()
        try:
            stack = _r1840_get_undo_stack(app)
        except Exception:
            stack = None
        idx = 1
        for path in paths:
            if not path:
                continue
            if not _os.path.exists(path):
                continue
            folder = _os.path.dirname(path)
            old_name = _os.path.basename(path)
            root, ext = _os.path.splitext(old_name)
            new_name = base + '_' + str(idx) + ext
            idx += 1
            new_path = _os.path.join(folder, new_name)
            if _os.path.exists(new_path):
                try:
                    _r1840_msg_error('Mehrfach-Rename', 'Ziel existiert bereits: ' + new_path)
                except Exception:
                    pass
                continue
            try:
                _os.rename(path, new_path)
            except Exception as exc:
                try:
                    _r1840_msg_error('Mehrfach-Rename', 'Fehler bei ' + path + ': ' + repr(exc))
                except Exception:
                    pass
                continue
            if stack is not None:
                try:
                    entry = {
                        'action': 'rename',
                        'old_path': path,
                        'new_path': new_path,
                        'time': _time_now(),
                    }
                    stack.append(entry)
                except Exception:
                    pass

    try:
        proxy = getattr(app, 'right_list', None)
        if proxy is not None and hasattr(proxy, 'refresh'):
            proxy.refresh()
    except Exception:
        pass



def action_tree_undo(app, *args, **kwargs):
    """Auto-generiert durch R1822: Platzhalter-Aktion fuer action_tree_undo."""
    try:
        _status(app, "Aktion 'action_tree_undo' ist noch nicht implementiert.")
    except Exception:
        try:
            print("[R1822] Aktion 'action_tree_undo' aufgerufen, aber _status nicht verfuegbar.")
        except Exception:
            pass

# ------------------------------------------------------------
# Auto-Placeholder (R1822) fuer action_undo
# ------------------------------------------------------------

def action_undo(app, *args, **kwargs):
    """Auto-generiert durch R1822: Platzhalter-Aktion fuer action_undo."""
    try:
        _status(app, "Aktion 'action_undo' ist noch nicht implementiert.")
    except Exception:
        try:
            print("[R1822] Aktion 'action_undo' aufgerufen, aber _status nicht verfuegbar.")
        except Exception:
            pass

# R1827: LearningEngine-Logging-Hook (defensiv, Zusatz)

def _learning_log_event(app, event_type: str, payload: Optional[dict] | None = None) -> None:
    # R2082: Sicheres Logging-Hook fuer LearningEngine und LearningJournal.
    # Wichtig: Fehler in den Diagnose-Systemen duerfen NIEMALS Intake/Runner crashen.

    # Bestehendes Ziel: LearningEngine (falls vorhanden)
    try:
        try:
            from modules import learning_engine  # type: ignore
            has_engine = True
        except Exception:
            learning_engine = None  # type: ignore[assignment]
            has_engine = False

        if has_engine:
            handler = getattr(learning_engine, 'learn_from_event', None)
            if handler is not None:
                data = payload or {}
                try:
                    safe_data = dict(data)
                except Exception:
                    safe_data = {'payload': str(data)}
                try:
                    handler(str(event_type), safe_data)
                except Exception:
                    pass
    except Exception:
        # Letzte Sicherheitsstufe – Intake darf NIEMALS crashen
        pass

    # Neues Ziel: LearningJournal (optional, falls Modul vorhanden)
    try:
        from modules import module_learningjournal as _lj  # type: ignore
        lj_handler = getattr(_lj, 'learning_log_event', None)
        if lj_handler is None:
            return

        msg = ''
        if isinstance(payload, dict):
            try:
                for key in ('message', 'status', 'phase', 'action'):
                    value = payload.get(key)
                    if value:
                        msg = str(value)
                        break
            except Exception:
                msg = ''
        if not msg:
            msg = 'event ' + str(event_type)

        if isinstance(payload, dict):
            try:
                lj_data = dict(payload)
            except Exception:
                lj_data = {'payload': str(payload)}
        elif payload is None:
            lj_data = {}
        else:
            lj_data = {'payload': str(payload)}

        try:
            lj_handler(str(event_type), msg, lj_data)
        except Exception:
            # LearningJournal-Logging ist diagnostisch – Fehler werden geschluckt
            return
    except Exception:
        # LJ-Logging darf ebenfalls niemals Intake/Runner crashen
        return


# =====================================================================
def _rR1837_get_intake_widgets(app) -> tuple[Optional[object], Optional[object], Optional[object], Optional[object]]:
    """
    Versucht, die relevanten Intake-Widgets am App-Objekt zu finden.

    Rueckgabe:
        (text_widget, var_name, var_ext, var_target_dir)
    """
    txt = None
    for attr in ("txt_intake", "intake_text", "txt_code", "editor"):
        txt = getattr(app, attr, None)
        if txt is not None:
            break

    var_name = getattr(app, "var_name", None)
    var_ext = getattr(app, "var_ext", None)
    var_target = getattr(app, "var_target_dir", None)

    return txt, var_name, var_ext, var_target


def _rR1837_status(app, msg: str) -> None:
    "Robuste Statusausgabe, ohne das UI zu killen."
    try:
        from tkinter import StringVar
    except Exception:  # pragma: no cover
        StringVar = None  # type: ignore

    try:
        if hasattr(app, "set_status") and callable(getattr(app, "set_status", None)):
            app.set_status(msg)
            return
    except Exception:
        pass

    # Fallback: status_var / var_status
    for attr in ("status_var", "var_status"):
        try:
            v = getattr(app, attr, None)
            if hasattr(v, "set"):
                v.set(msg)
                return
        except Exception:
            continue

    # Letzter Fallback: print
    try:
        print(f"[Intake] {msg}")
    except Exception:
        pass


def _rR1837_get_text_content(txt_widget) -> str:
    try:
        return txt_widget.get("1.0", "end-1c")
    except Exception:
        return ""


def _rR1837_detect_name_ext_from_text(text: str) -> tuple[str, str]:
    """Versucht, Name und Endung aus dem Text zu ermitteln.

    Bevorzugt module_code_intake.detect_name_and_ext, wenn vorhanden.
    """
    t = (text or "").strip()

    # 1) Bevorzugt bestehende Heuristik aus module_code_intake nutzen
    if _mod_intake_r1837 is not None and hasattr(_mod_intake_r1837, "detect_name_and_ext"):
        try:
            name, ext = _mod_intake_r1837.detect_name_and_ext(t)  # type: ignore[attr-defined]
            name = (name or "").strip()
            ext = (ext or "")
            if ext:
                # Wenn Intake uns eine gueltige Endung liefert, direkt uebernehmen
                return name, ext
        except Exception:
            # Intake soll nie wegen einer kaputten Helper-Funktion crashen
            pass

    import re as _re

    # 2) Fallback: Runner-Name und Endung direkt aus dem Text ableiten
    m = _re.search(r"\bR(\d{3,5}[a-zA-Z]?)\b", t)
    name = f"R{m.group(1)}" if m else ""

    lowered = t.lower()

    # Batch-Erkennung: nur echte Batch-Muster, kein nacktes "cmd" mehr
    is_batch = False
    try:
        if lowered.startswith("@echo off") or "setlocal" in lowered or "%~dp0" in t:
            is_batch = True
        elif _re.search(r"^\s*(?:rem|::)\b", t, _re.IGNORECASE | _re.MULTILINE):
            is_batch = True
    except Exception:
        is_batch = False

    # Python-Erkennung
    is_python = (
        "import " in t
        or "def " in t
        or "class " in t
        or "print(" in t
        or ".py" in t
        or "python" in lowered
    )

    if is_batch:
        ext = ".cmd"
    elif is_python:
        ext = ".py"
    else:
        # Default: Python, falls weder Batch noch Python klar erkannt wurde
        ext = ".py"

    return name, ext


def action_new(app) -> None:
    "Intake leeren und Felder zuruecksetzen (R1970)."
    txt, var_name, var_ext, var_target = _rR1837_get_intake_widgets(app)
    if txt is not None:
        try:
            txt.delete("1.0", "end")
        except Exception:
            pass
    try:
        if hasattr(var_name, "set"):
            var_name.set("")
    except Exception:
        pass
    try:
        if hasattr(var_ext, "set"):
            var_ext.set("")
    except Exception:
        pass
    _rR1837_status(app, "Intake geleert.")
    try:
        _learning_log_event(app, "intake_new", "ok")  # type: ignore[name-defined]
    except Exception:
        pass
# [DEPRECATED_PHASE1_R2027]: Aeltere action_detect-Version, ueberlagert durch finale Definition.

def action_save(app) -> None:
    "Intake-Inhalt im Zielordner als Datei speichern (R1970 mit Syntax-Check)."
    import os as _os

    txt, var_name, var_ext, var_target = _rR1837_get_intake_widgets(app)
    if txt is None or var_name is None or var_ext is None or var_target is None:
        _rR1837_status(app, "Speichern: Intake-Felder nicht vollständig vorhanden.")
        try:
            _learning_log_event(app, "intake_save", "no_widgets")  # type: ignore[name-defined]
        except Exception:
            pass
        return

    try:
        name = (var_name.get() or "").strip()
        ext = (var_ext.get() or "").strip()
        target = (var_target.get() or "").strip()
    except Exception:
        _rR1837_status(app, "Speichern: Fehler beim Lesen der Variablen.")
        return

    if not name:
        _rR1837_status(app, "Speichern: Kein Dateiname gesetzt.")
        return

    # Endung normalisieren: Feld ohne Punkt, Pfad mit Punkt
    ext = ext.lstrip(".")
    if not ext:
        _rR1837_status(app, "Speichern: Keine Dateiendung gesetzt.")
        return
    dot_ext = "." + ext

    if not target:
        _rR1837_status(app, "Speichern: Kein Zielordner gesetzt.")
        return

    # Syntaxpruefung nur fuer Python-Dateien
    is_py = ext.lower() == "py"
    if is_py:
        if _intake_syntax_check(app, for_save=True):
            # Fehler -> nicht speichern
            return

    try:
        _os.makedirs(target, exist_ok=True)
    except Exception as exc:
        _rR1837_status(app, f"Speichern: Zielordner nicht nutzbar ({exc}).")
        return

    path = _os.path.join(target, f"{name}{dot_ext}")
    content = _rR1837_get_text_content(txt)

    try:
        with open(path, "w", encoding="utf-8") as f:
            f.write(content)
        _rR1837_status(app, f"Gespeichert: {path}")
        try:
            _learning_log_event(app, "intake_save", "ok")  # type: ignore[name-defined]
        except Exception:
            pass
    except Exception as exc:  # pragma: no cover
        _rR1837_status(app, f"Speichern fehlgeschlagen: {exc}")
        try:
            _learning_log_event(app, "intake_save", "error")  # type: ignore[name-defined]
        except Exception:
            pass


def action_undo(app) -> None:
    "Letzte Aenderung im Intake-Editor rueckgaengig machen."
    txt, var_name, var_ext, var_target = _rR1837_get_intake_widgets(app)
    if txt is None:
        _rR1837_status(app, "Undo: Kein Intake-Widget gefunden.")
        return
    try:
        txt.edit_undo()
        _rR1837_status(app, "Undo im Intake ausgeführt.")
        try:
            _learning_log_event(app, "intake_undo", "ok")  # type: ignore[name-defined]
        except Exception:
            pass
    except Exception:
        _rR1837_status(app, "Undo im Intake nicht verfügbar.")


def action_run(app) -> None:
    "Versucht, die aktuell gespeicherte Datei zu starten (Runner / Script)."
    import os as _os

    txt, var_name, var_ext, var_target = _rR1837_get_intake_widgets(app)
    if var_name is None or var_ext is None or var_target is None:
        _rR1837_status(app, "Run: Intake-Felder unvollständig.")
        return

    try:
        name = (var_name.get() or "").strip()
        ext = (var_ext.get() or "").strip()
        target = (var_target.get() or "").strip()
    except Exception:
        _rR1837_status(app, "Run: Fehler beim Auslesen der Felder.")
        return

    if not (name and ext and target):
        _rR1837_status(app, "Run: Name/Endung/Zielordner unvollständig.")
        return

    if not ext.startswith("."):
        ext = "." + extxt

    path = _os.path.join(target, f"{name}{ext}")
    if not _os.path.isfile(path):
        _rR1837_status(app, f"Run: Datei nicht gefunden: {path}")
        return

        # R2247_IntakeToolsRunner: tools\\R####.cmd/.py always via module_runner_exec (central logging)
    try:
        p_norm = path.replace('/', '\\')
        mrun = __import__('re').search(r"\\\\tools\\\\(R\\d{4})\\.(cmd|py)$", p_norm, __import__('re').IGNORECASE)
        if mrun:
            rid = mrun.group(1).upper()
            runner_py = f"tools\\\\{rid}.py"
            module_runner_exec.run(runner_py, title=f"Intake Run {rid}")
            try:
                _status(app, f"Run gestartet (RunnerExec): {rid}")
            except Exception:
                pass
            return
    except Exception:
        pass

# Wenn module_code_intake._run_cmd vorhanden ist, verwenden
    if _mod_intake_r1837 is not None and hasattr(_mod_intake_r1837, "_run_cmd"):
        try:
            _mod_intake_r1837._run_cmd(path)  # type: ignore[attr-defined]
            _rR1837_status(app, f"Run gestartet: {path}")
            try:
                _learning_log_event(app, "intake_run", "ok")  # type: ignore[name-defined]
            except Exception:
                pass
            return
        except Exception as exc:  # pragma: no cover
            _rR1837_status(app, f"Run fehlgeschlagen: {exc}")
            return

    # Fallback: os.startfile
    try:
        _os.startfile(path)  # type: ignore[attr-defined]
        _rR1837_status(app, f"Run gestartet (Fallback): {path}")
        try:
            _learning_log_event(app, "intake_run", "ok_fallback")  # type: ignore[name-defined]
        except Exception:
            pass
    except Exception as exc:  # pragma: no cover
        _rR1837_status(app, f"Run (Fallback) fehlgeschlagen: {exc}")
# R1841B_START_NO_CONFIRM
# Delete ohne Bestaetigungsdialog


def action_tree_delete(app, *args, **kwargs):
    import os as _os
    import time as _time

    paths = []
    try:
        from modules import ui_project_tree as _uipt
        try:
            candidates = _uipt.get_selected_paths(app)
        except Exception:
            candidates = []
        if candidates:
            for p in candidates:
                if p and p not in paths:
                    paths.append(p)
        else:
            try:
                single = _uipt.get_selected_path(app)
            except Exception:
                single = None
            if single:
                paths.append(single)
    except Exception:
        paths = []

    if not paths:
        try:
            from tkinter import messagebox as _mb
            _mb.showinfo("Loeschen", "Keine Datei ausgewaehlt.")
        except Exception:
            pass
        return

    root_dir = _os.path.abspath(_os.path.join(_os.path.dirname(__file__), ".."))
    trash_dir = _os.path.join(root_dir, "_Trash")
    try:
        _os.makedirs(trash_dir, exist_ok=True)
    except Exception:
        return

    stack = getattr(app, "_tree_undo_stack", None)
    if not isinstance(stack, list):
        stack = []
        try:
            app._tree_undo_stack = stack
        except Exception:
            pass

    for path in paths:
        if not path:
            continue
        if not _os.path.exists(path):
            continue

        base = _os.path.basename(path)
        ts = _time.strftime("%Y%m%d_%H%M%S")
        dest = _os.path.join(trash_dir, ts + "__" + base)
        counter = 1
        while _os.path.exists(dest):
            dest = _os.path.join(trash_dir, ts + "_" + str(counter) + "__" + base)
            counter += 1

        try:
            _os.rename(path, dest)
        except Exception:
            continue

        stack.append({
            "action": "delete",
            "original": path,
            "trash": dest,
            "time": _time.time()
        })

    try:
        proxy = getattr(app, "right_list", None)
        if proxy and hasattr(proxy, "refresh"):
            proxy.refresh()
    except Exception:
        pass


# R1841B_END_NO_CONFIRM
# R1848_START_TREE_CONTEXT_MENU
# Kontextmenue fuer rechte Tree-Liste (In Intake laden, Explorer, Pfad kopieren, Umbenennen, In den Papierkorb)

import os as _r1848_os
import threading as _r1848_thread

try:
    import tkinter as _r1848_tk
    from tkinter import messagebox as _r1848_mb
except Exception:
    _r1848_tk = None
    _r1848_mb = None

def _r1848_get_selected_path(app):
    """Pfad der aktuellen Auswahl aus ui_project_tree.get_selected_path(app)."""
    try:
        from modules import ui_project_tree as _r1848_uipt  # type: ignore
    except Exception:
        return None
    try:
        return _r1848_uipt.get_selected_path(app)
    except Exception:
        return None

def action_tree_open_in_explorer(app, *args, **kwargs):
    """Markierte Datei im Explorer oeffnen (oder Info anzeigen)."""
    path = _r1848_get_selected_path(app)
    if not path:
        if _r1848_mb:
            try:
                _r1848_mb.showinfo("Explorer", "Keine Datei ausgewaehlt.")
            except Exception:
                pass
        return
    try:
        if _r1848_os.path.exists(path):
            _r1848_os.startfile(path)
        else:
            if _r1848_mb:
                try:
                    _r1848_mb.showerror("Explorer", "Pfad existiert nicht mehr:\n" + path)
                except Exception:
                    pass
    except Exception as exc:
        if _r1848_mb:
            try:
                _r1848_mb.showerror("Explorer", "Fehler beim Oeffnen:\n" + repr(exc))
            except Exception:
                pass

def action_tree_copy_path(app, *args, **kwargs):
    """Pfad der markierten Datei in die Zwischenablage kopieren."""
    path = _r1848_get_selected_path(app)
    if not path:
        if _r1848_mb:
            try:
                _r1848_mb.showinfo("Pfad kopieren", "Keine Datei ausgewaehlt.")
            except Exception:
                pass
        return
    try:
        # app ist das Tk-Hauptfenster
        app.clipboard_clear()
        app.clipboard_append(path)
        if _r1848_mb:
            try:
                _r1848_mb.showinfo("Pfad kopiert", path)
            except Exception:
                pass
    except Exception:
        pass

def _r1848_attach_context_menu(app):
    """Rechtsklick-Kontextmenue an app.tree anbinden."""
    if _r1848_tk is None:
        return
    tree = getattr(app, "tree", None)
    if tree is None:
        return

    menu = _r1848_tk.Menu(tree, tearoff=False)

    def _update_selection(event):
        try:
            row_id = tree.identify_row(event.y)
            if row_id:
                tree.selection_set(row_id)
        except Exception:
            pass

    def _cmd_open_intake():
        try:
            from modules.ui_project_tree import open_selected_in_intake  # type: ignore
            open_selected_in_intake(app)
        except Exception:
            pass

    def _cmd_open_explorer():
        try:
            action_tree_open_in_explorer(app)
        except Exception:
            pass

    def _cmd_copy_path():
        try:
            action_tree_copy_path(app)
        except Exception:
            pass

    def _cmd_rename():
        try:
            action_tree_rename(app)
        except Exception:
            pass

    def _cmd_trash():
        try:
            action_tree_delete(app)
        except Exception:
            pass

    menu.add_command(label="In Intake laden", command=_cmd_open_intake)
    menu.add_command(label="Explorer öffnen", command=_cmd_open_explorer)
    menu.add_command(label="Pfad kopieren", command=_cmd_copy_path)
    menu.add_separator()
    menu.add_command(label="Umbenennen…", command=_cmd_rename)
    menu.add_command(label="In den Papierkorb", command=_cmd_trash)

    def _on_button3(event, _menu=menu):
        _update_selection(event)
        try:
            _menu.tk_popup(event.x_root, event.y_root)
        finally:
            try:
                _menu.grab_release()
            except Exception:
                pass

    try:
        tree.bind("<Button-3>", lambda event: _on_button3(event), add="+")
    except Exception:
        pass

# build_tree aus ui_project_tree wrappen, damit Kontextmenue nach dem Aufbau gesetzt wird
try:
    from modules import ui_project_tree as _r1848_uipt  # type: ignore
    _r1848_orig_build_tree = getattr(_r1848_uipt, "build_tree", None)
except Exception:
    _r1848_orig_build_tree = None

def _r1848_install_build_tree_wrapper():
    if _r1848_orig_build_tree is None:
        return

    def _wrapped_build_tree(parent, app):
        result = _r1848_orig_build_tree(parent, app)
        try:
            _r1848_attach_context_menu(app)
        except Exception:
            pass
        return result

    try:
        _r1848_uipt.build_tree = _wrapped_build_tree  # type: ignore
    except Exception:
        pass

_r1848_install_build_tree_wrapper()

# R1848_END_TREE_CONTEXT_MENU
# R1851_START_RUNNERPOPUPS_INI
# SonderRunner-Popups mit Persistenz in ShrimpDev.ini ([RunnerPopups]).

import os as _r1851_os
import subprocess as _r1851_sub
import threading as _r1851_thread

try:
    import tkinter as _r1851_tk
    from tkinter import messagebox as _r1851_mb
    import tkinter.font as _r1851_font
except Exception:
    _r1851_tk = None
    _r1851_mb = None
    _r1851_font = None

def _r1851_load_ini():
    '''ShrimpDev.ini ueber modules.config_loader.load() einlesen.'''
    try:
        from modules import config_loader as _r1851_cfg  # type: ignore
    except Exception:
        return None
    try:
        return _r1851_cfg.load()
    except Exception:
        return None

def _r1851_save_ini(cfg):
    '''ShrimpDev.ini ueber modules.config_loader.save() speichern.'''
    try:
        from modules import config_loader as _r1851_cfg  # type: ignore
    except Exception:
        return
    try:
        _r1851_cfg.save(cfg)
    except Exception:
        return

def _r1851_get_runnerpopup_flag(runner_id: str) -> bool:
    '''True = Popup anzeigen, False = unterdruecken (Default: True).'''
    cfg = _r1851_load_ini()
    if cfg is None:
        return True
    section = "RunnerPopups"
    if not cfg.has_section(section):
        return True
    try:
        return cfg.getboolean(section, runner_id, fallback=True)
    except Exception:
        return True

def _r1851_set_runnerpopup_flag(runner_id: str, show: bool) -> None:
    cfg = _r1851_load_ini()
    if cfg is None:
        return
    section = "RunnerPopups"
    if not cfg.has_section(section):
        cfg.add_section(section)
    cfg.set(section, runner_id, "true" if show else "false")
    _r1851_save_ini(cfg)

def _r1851_show_popup(app, title: str, text: str, runner_id: str):
    '''Popup fuer Runner-Ausgaben mit Checkbox "nicht mehr anzeigen".'''
    if _r1851_tk is None:
        return

    content = text or "(keine Ausgabe)"

    def _build():
        try:
            win = _r1851_tk.Toplevel(app)
        except Exception:
            win = _r1851_tk.Toplevel()
        win.title(str(title))
        win.geometry("900x600")
        # R2213: center+topmost runner popup (existing popup, no new UI)
        try:
            win.update_idletasks()
            sw = win.winfo_screenwidth()
            sh = win.winfo_screenheight()
            w = win.winfo_width() or 900
            h = win.winfo_height() or 600
            x = max(0, int((sw - w) / 2))
            y = max(0, int((sh - h) / 4))  # leicht nach oben (TOP)
            win.geometry(f"{w}x{h}+{x}+{y}")
        except Exception:
            pass
        try:
            win.attributes("-topmost", True)
            win.lift()
            win.focus_force()
        except Exception:
            pass
        try:
            win.grab_set()
        except Exception:
            pass

        frame = _r1851_tk.Frame(win)
        frame.pack(expand=True, fill="both")

        scrollbar = _r1851_tk.Scrollbar(frame)
        scrollbar.pack(side="right", fill="y")

        txt = _r1851_tk.Text(frame, wrap="word")
        txt.pack(side="left", expand=True, fill="both")
        txt.config(yscrollcommand=scrollbar.set)
        scrollbar.config(command=txt.yview)

        if _r1851_font is not None:
            try:
                mono = _r1851_font.Font(family="Courier New", size=10)
                txt.configure(font=mono)
            except Exception:
                pass

        txt.insert("1.0", content)
        txt.config(state="normal")

        ctrl = _r1851_tk.Frame(win)
        ctrl.pack(fill="x", pady=4)

        var_suppress = _r1851_tk.BooleanVar(
            value=not _r1851_get_runnerpopup_flag(runner_id)
        )
        chk = _r1851_tk.Checkbutton(
            ctrl,
            text="nicht mehr anzeigen",
            variable=var_suppress
        )
        chk.pack(side="left", padx=4)

        def _on_close():
            try:
                _r1851_set_runnerpopup_flag(runner_id, not bool(var_suppress.get()))
            except Exception:
                pass
            try:
                win.destroy()
            except Exception:
                pass

        btn_close = _r1851_tk.Button(ctrl, text="Schliessen", command=_on_close)
        btn_close.pack(side="right", padx=8)

    try:
        try:
            app.after(0, _build)
        except Exception:
            _build()
    except Exception:
        return

def _r1851_run_cmd_in_background(app, cmd_path: str, label: str, runner_id: str):
    '''Runner-CMD im Hintergrund ausfuehren und ggf. Popup anzeigen.'''
    def worker():
        try:
            proc = _r1851_sub.Popen(
                ["cmd", "/c", cmd_path],
                stdout=_r1851_sub.PIPE,
                stderr=_r1851_sub.PIPE,
                text=True
            )
            out, err = proc.communicate()

            lines = []
            lines.append("Runner: " + cmd_path)
            lines.append("Label : " + label)
            lines.append("Exit  : " + str(proc.returncode))
            lines.append("")
            if out:
                lines.append("--- STDOUT ---")
                lines.append(out)
            if err:
                lines.append("")
                lines.append("--- STDERR ---")
                lines.append(err)
            text = "\n".join(lines)

            # Immer ins Log schreiben, Popup nur wenn Flag == True
            # Zentraler Runner-Log (exception_logger)
            try:
                from . import exception_logger as _elog  # type: ignore
                def _trunc(s, lim=8000):
                    try:
                        if s is None:
                            return ""
                        s = str(s)
                        if len(s) <= lim:
                            return s
                        return s[:lim] + "\n... (truncated)"
                    except Exception:
                        return ""
                # START/OUTPUT/END
                try:
                    _elog.log_runner_start(runner_id, label)
                except Exception:
                    pass
                if out:
                    try:
                        _elog.log_runner_output(runner_id, _trunc(out), "STDOUT")
                    except Exception:
                        pass
                if err:
                    try:
                        _elog.log_runner_output(runner_id, _trunc(err), "STDERR")
                    except Exception:
                        pass
                try:
                    _elog.log_runner_end(runner_id, proc.returncode)
                except Exception:
                    pass
            except Exception:
                pass
            if _r1851_get_runnerpopup_flag(runner_id):
                _r1851_show_popup(app, label + " – Ausgabe", text, runner_id)

        except Exception:
            return

    _r1851_thread.Thread(target=worker, daemon=True).start()

def _r1851_run_tools_runner(app, runner_id: str, label: str):
    '''Wrapper fuer SonderRunner-Buttons (FutureFix etc.).'''
    try:
        here = _r1851_os.path.abspath(_r1851_os.path.dirname(__file__))
        root_dir = _r1851_os.path.abspath(_r1851_os.path.join(here, ".."))
    except Exception:
        return
    tools_dir = _r1851_os.path.join(root_dir, "tools")
    cmd_path = _r1851_os.path.join(tools_dir, runner_id + ".cmd")

    if not _r1851_os.path.isfile(cmd_path):
        msg = "Runner-Datei nicht gefunden:\n" + cmd_path
        if _r1851_mb is not None:
            try:
                _r1851_mb.showerror(label, msg)
                return
            except Exception:
                pass
        return

    _r1851_run_cmd_in_background(app, cmd_path, label, runner_id)

# Actions ueberschreiben (letzte Definition gewinnt)
def action_guard_futurefix(app, *args, **kwargs):      # type: ignore[override]
    _r1851_run_tools_runner(app, "R9997", "FutureFix")

def action_guard_futurefix_safe(app, *args, **kwargs):  # type: ignore[override]
    _r1851_run_tools_runner(app, "R1351", "FutureFix Safe")

def action_r9998(app, *args, **kwargs):                 # type: ignore[override]
    _r1851_run_tools_runner(app, "R9998", "Build Tools")

def action_r9999(app, *args, **kwargs):                 # type: ignore[override]
    _r1851_run_tools_runner(app, "R9999", "Diagnose")

# R1851_END_RUNNERPOPUPS_INI


# R1852_START_RUNNERPOPUPS_INI
# SonderRunner-Popups mit Persistenz in ShrimpDev.ini ([RunnerPopups]).

import os as _r1852_os
import subprocess as _r1852_sub
import threading as _r1852_thread

try:
    import tkinter as _r1852_tk
    from tkinter import messagebox as _r1852_mb
    import tkinter.font as _r1852_font
except Exception:
    _r1852_tk = None
    _r1852_mb = None
    _r1852_font = None

def _r1852_load_ini():
    """ShrimpDev.ini ueber modules.config_loader.load() einlesen."""
    try:
        from modules import config_loader as _r1852_cfg  # type: ignore
    except Exception:
        return None
    try:
        return _r1852_cfg.load()
    except Exception:
        return None

def _r1852_save_ini(cfg):
    """ShrimpDev.ini ueber modules.config_loader.save() speichern."""
    try:
        from modules import config_loader as _r1852_cfg  # type: ignore
    except Exception:
        return
    try:
        _r1852_cfg.save(cfg)
    except Exception:
        return

def _r1852_get_runnerpopup_flag(runner_id: str) -> bool:
    """True = Popup anzeigen, False = unterdruecken (Default: True)."""
    cfg = _r1852_load_ini()
    if cfg is None:
        return True
    section = "RunnerPopups"
    if not cfg.has_section(section):
        return True
    try:
        return cfg.getboolean(section, runner_id, fallback=True)
    except Exception:
        return True

def _r1852_set_runnerpopup_flag(runner_id: str, show: bool) -> None:
    cfg = _r1852_load_ini()
    if cfg is None:
        return
    section = "RunnerPopups"
    if not cfg.has_section(section):
        cfg.add_section(section)
    cfg.set(section, runner_id, "true" if show else "false")
    _r1852_save_ini(cfg)

def _r1852_show_popup(app, title: str, text: str, runner_id: str):
    """Popup fuer Runner-Ausgaben mit Checkbox 'nicht mehr anzeigen'."""
    if _r1852_tk is None:
        return

    content = text or "(keine Ausgabe)"

    def _build():
        # Parent bestimmen
        try:
            if isinstance(app, _r1852_tk.Tk) or isinstance(app, _r1852_tk.Toplevel):
                parent = app
            else:
                parent = _r1852_tk._default_root or _r1852_tk.Tk()
        except Exception:
            parent = _r1852_tk._default_root or _r1852_tk.Tk()

        win = _r1852_tk.Toplevel(parent)
        win.title(str(title))
        win.geometry("900x600")
        try:
            win.grab_set()
        except Exception:
            pass
        try:
            win.lift()
            win.focus_force()
        except Exception:
            pass

        frame = _r1852_tk.Frame(win)
        frame.pack(expand=True, fill="both")

        scrollbar = _r1852_tk.Scrollbar(frame)
        scrollbar.pack(side="right", fill="y")

        txt = _r1852_tk.Text(frame, wrap="word")
        txt.pack(side="left", expand=True, fill="both")
        txt.config(yscrollcommand=scrollbar.set)
        scrollbar.config(command=txt.yview)

        if _r1852_font is not None:
            try:
                mono = _r1852_font.Font(family="Courier New", size=10)
                txt.configure(font=mono)
            except Exception:
                pass

        txt.insert("1.0", content)
        txt.config(state="normal")

        ctrl = _r1852_tk.Frame(win)
        ctrl.pack(fill="x", pady=4)

        var_suppress = _r1852_tk.BooleanVar(
            value=not _r1852_get_runnerpopup_flag(runner_id)
        )
        chk = _r1852_tk.Checkbutton(
            ctrl,
            text="nicht mehr anzeigen",
            variable=var_suppress
        )
        chk.pack(side="left", padx=4)

        def _on_close():
            try:
                _r1852_set_runnerpopup_flag(runner_id, not bool(var_suppress.get()))
            except Exception:
                pass
            try:
                win.destroy()
            except Exception:
                pass

        btn_close = _r1852_tk.Button(ctrl, text="Schliessen", command=_on_close)
        btn_close.pack(side="right", padx=8)

    try:
        try:
            app.after(0, _build)
        except Exception:
            _build()
    except Exception:
        return

def _r1852_run_cmd_in_background(app, cmd_path: str, label: str, runner_id: str):
    """Runner-CMD im Hintergrund ausfuehren und ggf. Popup anzeigen."""
    def worker():
        try:
            proc = _r1852_sub.Popen(
                ["cmd", "/c", cmd_path],
                stdout=_r1852_sub.PIPE,
                stderr=_r1852_sub.PIPE,
                text=True
            )
            out, err = proc.communicate()

            lines = []
            lines.append("Runner: " + cmd_path)
            lines.append("Label : " + label)
            lines.append("Exit  : " + str(proc.returncode))
            lines.append("")
            if out:
                lines.append("--- STDOUT ---")
                lines.append(out)
            if err:
                lines.append("")
                lines.append("--- STDERR ---")
                lines.append(err)
            text = "\n".join(lines)

            # Popup nur wenn Flag == True
            if _r1852_get_runnerpopup_flag(runner_id):
                _r1852_show_popup(app, label + " – Ausgabe", text, runner_id)

        except Exception:
            return

    _r1852_thread.Thread(target=worker, daemon=True).start()

def _r1852_run_tools_runner(app, runner_id: str, label: str):
    """Wrapper fuer SonderRunner-Buttons (FutureFix etc.)."""
    try:
        here = _r1852_os.path.abspath(_r1852_os.path.dirname(__file__))
        root_dir = _r1852_os.path.abspath(_r1852_os.path.join(here, ".."))
    except Exception:
        return
    tools_dir = _r1852_os.path.join(root_dir, "tools")
    cmd_path = _r1852_os.path.join(tools_dir, runner_id + ".cmd")

    if not _r1852_os.path.isfile(cmd_path):
        msg = "Runner-Datei nicht gefunden:\n" + cmd_path
        if _r1852_mb is not None:
            try:
                _r1852_mb.showerror(label, msg)
                return
            except Exception:
                pass
        return

    _r1852_run_cmd_in_background(app, cmd_path, label, runner_id)

# Actions ueberschreiben (letzte Definition gewinnt)
def action_guard_futurefix(app, *args, **kwargs):      # type: ignore[override]
    _r1852_run_tools_runner(app, "R9997", "FutureFix")

def action_guard_futurefix_safe(app, *args, **kwargs):  # type: ignore[override]
    _r1852_run_tools_runner(app, "R1351", "FutureFix Safe")

def action_r9998(app, *args, **kwargs):                 # type: ignore[override]
    _r1852_run_tools_runner(app, "R9998", "Build Tools")

def action_r9999(app, *args, **kwargs):                 # type: ignore[override]
    _r1852_run_tools_runner(app, "R9999", "Diagnose")

# R1852_END_RUNNERPOPUPS_INI

# [R1901] Hilfsfunktionen fuer zentrale Config-Nutzung
from pathlib import Path as _PathForActions
from modules import config_manager as _cfg_actions

def get_workspace_root_for_actions() -> _PathForActions:
    """Liefert den workspace_root fuer Dateioperationen in logic_actions.

    Diese Funktion kapselt die zentrale Config-Nutzung, damit kuenftige
    Aenderungen an einem Ort gebuendelt sind.
    """
    return _cfg_actions.get_workspace_root()

def is_quiet_mode_enabled() -> bool:
    """Liefert True, wenn quiet_mode in der Config aktiviert ist."""
    return _cfg_actions.get_quiet_mode()
# --- R1979 Intake Detect Core ---


def _r2020_detect_name_ext_from_text(text: str) -> tuple[str, str]:
    """R2020-Intake-Erkennung: saubere Trennung zwischen .py und .cmd.

    - Name: erste gefundene Runner-ID (R#### oder R####a/b/...)
    - Endung:
        * .cmd bei typischen Batch-Merkmalen (ohne nacktes "cmd" im Text)
        * sonst .py (Python ist Default)
    """
    t = (text or "").strip()

    import re as _re

    # 0) Header/FILE-Marker gewinnt (Header-first, verhindert falsche Runner-ID Erkennung)
    header_path = ''
    try:
        mfile = _re.search(r'^\s*(?:#|;|//|REM\s+)\s*(?:file|path)\s*:\s*([^\s]+)\s*$', t, _re.IGNORECASE | _re.MULTILINE)
        if not mfile:
            mfile = _re.search(r'@@file=([^@]+)@@', t, _re.IGNORECASE)
        if not mfile:
            mfile = _re.search(r'^\s*(?:REM\s+FILE|;\s*FILE)\s+([^\s]+)\s*$', t, _re.IGNORECASE | _re.MULTILINE)
        if mfile:
            header_path = (mfile.group(1) or '').strip().strip('"').strip("'")
    except Exception:
        header_path = ''

    if header_path:
        hp = header_path.replace('\\', '/').split('/')[-1]
        ext2 = '.py'
        if '.' in hp:
            ext2 = '.' + hp.split('.')[-1].lower()
        name2 = hp.rsplit('.', 1)[0] if '.' in hp else hp
        if name2:
            return name2, ext2

    # 0) Header/FILE-Marker gewinnt (Header-first, verhindert falsche Runner-ID Erkennung)
    header_path = ''
    try:
        mfile = _re.search(r'^\s*(?:#|;|//|REM\s+)\s*(?:file|path)\s*:\s*([^\s]+)\s*$', t, _re.IGNORECASE | _re.MULTILINE)
        if not mfile:
            mfile = _re.search(r'@@file=([^@]+)@@', t, _re.IGNORECASE)
        if not mfile:
            mfile = _re.search(r'^\s*(?:REM\s+FILE|;\s*FILE)\s+([^\s]+)\s*$', t, _re.IGNORECASE | _re.MULTILINE)
        if mfile:
            header_path = (mfile.group(1) or '').strip().strip('"').strip("'")
    except Exception:
        header_path = ''

    if header_path:
        hp = header_path.replace('\\', '/').split('/')[-1]
        ext2 = '.py'
        if '.' in hp:
            ext2 = '.' + hp.split('.')[-1].lower()
        name2 = hp.rsplit('.', 1)[0] if '.' in hp else hp
        if name2:
            return name2, ext2

    # Runner-Name
    m = _re.search(r"\bR(\d{3,5}[a-zA-Z]?)\b", t)
    name = f"R{m.group(1)}" if m else ""

    lowered = t.lower()

    # Batch-Erkennung: nur echte Batch-Muster, kein nacktes "cmd"
    is_batch = False
    try:
        if lowered.startswith("@echo off") or "setlocal" in lowered or "%~dp0" in t:
            is_batch = True
        elif _re.search(r"^\s*(?:rem|::)\b", t, _re.IGNORECASE | _re.MULTILINE):
            is_batch = True
    except Exception:
        is_batch = False

    # Python-Erkennung
    is_python = (
        "import " in t
        or "def " in t
        or "class " in t
        or "print(" in t
        or ".py" in lowered
        or "python" in lowered
    )

    if is_batch and not is_python:
        ext = ".cmd"
    else:
        # Standardfall: Python, falls nicht eindeutig Batch
        ext = ".py"

    return name, ext


def _r1979_intake_detect_core(app, *_args, **_kwargs) -> None:
    """Zentrale Intake-Erkennung (Name/Endung) fuer Buttons & LEDs.

    Nutzt:
      - _rR1837_get_intake_widgets(app)  -> (txt, var_name, var_ext, var_target)
      - _rR1837_detect_name_ext_from_text(text) -> (name, ext)
    und setzt:
      - var_name, var_ext (ohne Punkt)
      - Statuszeile: "Erkannt: Name.ext"
    """
    try:
        txt, var_name, var_ext, _target = _rR1837_get_intake_widgets(app)  # type: ignore[name-defined]
    except Exception:
        txt, var_name, var_ext = None, None, None

    if txt is None:
        try:
            _status(app, "Intake-Editor nicht gefunden.")  # type: ignore[name-defined]
        except Exception:
            pass
        return

    try:
        raw = txt.get("1.0", "end")
    except Exception:
        try:
            _status(app, "Intake-Inhalt konnte nicht gelesen werden.")
        except Exception:
            pass
        return

    text = (raw or "").strip()
    if not text:
        try:
            _status(app, "Keine Eingabe im Intake fuer Erkennung.")
        except Exception:
            pass
        return

    try:
        name, ext = _r2020_detect_name_ext_from_text(text)  # type: ignore[name-defined]
    except Exception:
        name, ext = "", ".py"

    name = name or "Intake"
    ext = ext or ".py"

    # R1992: Batch-Inhalt erzwingt CMD-Endung, auch wenn Fallback ".py" ergibt
    try:
        lowered = text.lower()
    except Exception:
        lowered = ""
    try:
        import re as _re  # type: ignore
    except Exception:  # pragma: no cover
        _re = None  # type: ignore
    # R2021: Python-Struktur gewinnt immer vor Batch-Heuristik
    is_batch = False
    is_python = False
    try:
        if "import " in text or "def " in text or "class " in text or "print(" in text:
            is_python = True
    except Exception:
        is_python = False
    try:
        if not is_python:
            # Typische Batch-/CMD-Muster
            if lowered.startswith("@echo off") or "setlocal" in lowered or "%~dp0" in text:
                is_batch = True
            if (not is_batch) and _re is not None:
                if _re.search(r"^\s*(?:rem|::)\b", text, _re.IGNORECASE | _re.MULTILINE):
                    is_batch = True
    except Exception:
        pass
    if is_batch:
        ext = ".cmd"

    # Endung bereinigen
    if ext.startswith("."):
        ext_clean = ext[1:]
    else:
        ext_clean = ext
        ext = "." + ext_clean

    # Name aktualisieren
    try:
        if hasattr(var_name, "set"):
            var_name.set(name)
        elif getattr(app, "entry_name", None) is not None:
            e = app.entry_name
            e.delete(0, "end")
            e.insert(0, name)
    except Exception:
        pass

    # Endung (ohne Punkt) aktualisieren
    try:
        if hasattr(var_ext, "set"):
            var_ext.set(ext_clean)
        elif getattr(app, "entry_ext", None) is not None:
            e = app.entry_ext
            e.delete(0, "end")
            e.insert(0, ext_clean)
    except Exception:
        pass

    # Statuszeile
    try:
        _status(app, f"Erkannt: {name}{ext}")
    except Exception:
        pass


def action_detect(app, *args, **kwargs):  # type: ignore[override]
    """Finale Intake-Erkennung (R1979-Wrapper).

    Alle bisherigen action_detect-Varianten werden durch diesen Wrapper
    uebersteuert, da diese Definition am Dateiende steht.
    """
    return _r1979_intake_detect_core(app, *args, **kwargs)

# --- Ende R1979 Intake Detect Core ---

# --- Legacy-Code archiviert durch R2032 (nicht mehr aktiv, nur Referenz) ---
# --- LEGACY_R2032: R1840_TOOLBAR_ACTIONS ---
# 
# 
# 
# 
# 
# # R1840_START_TOOLBAR_ACTIONS
# # [DEPRECATED_PHASE1_R2027]: Toolbar-Aktionen (Tree Delete/Rename) alt – ueberlagert durch R1841B/R1848.
# # ToolbarRightFix (Soft Delete) - automatische Ergänzung durch R1840
# #
# # Diese Implementierungen ersetzen die Platzhalter für:
# #   action_tree_delete, action_tree_rename, action_tree_undo
# # und arbeiten auf Basis der rechten Runner-Liste.
# #
# # Abhängigkeiten:
# #   - ui_project_tree.get_selected_path(app) für Pfadermittlung
# #   - app.right_list.refresh() (RightListProxy) für Refresh, falls vorhanden
# 
# import os as _r1840_os
# import time as _r1840_time
# 
# try:
#     import tkinter as _r1840_tk
#     from tkinter import messagebox as _r1840_messagebox
#     from tkinter import simpledialog as _r1840_simpledialog
# except Exception:
#     _r1840_tk = None
#     _r1840_messagebox = None
#     _r1840_simpledialog = None
# 
# 
# def _r1840_log(msg):
#     """Lokales Logging fuer Toolbar-Aktionen (R1840)."""
#     try:
#         root_dir = _r1840_os.path.abspath(
#             _r1840_os.path.join(_r1840_os.path.dirname(__file__), "..")
#         )
#         log_path = _r1840_os.path.join(root_dir, "debug_output.txt")
#         line = "[R1840-TREE] " + _r1840_time.strftime("%Y-%m-%d %H:%M:%S") + " " + str(msg) + "\n"
#         with open(log_path, "a", encoding="utf-8") as f:
#             f.write(line)
#     except Exception:
#         pass
# 
# 
# def _r1840_msg_info(title, text):
#     if _r1840_messagebox is not None:
#         try:
#             _r1840_messagebox.showinfo(title, text)
#             return
#         except Exception:
#             pass
#     _r1840_log("INFO [" + str(title) + "]: " + str(text))
# 
# 
# def _r1840_msg_error(title, text):
#     if _r1840_messagebox is not None:
#         try:
#             _r1840_messagebox.showerror(title, text)
#             return
#         except Exception:
#             pass
#     _r1840_log("ERROR [" + str(title) + "]: " + str(text))
# 
# 
# def _r1840_msg_yesno(title, text):
#     if _r1840_messagebox is not None:
#         try:
#             return bool(_r1840_messagebox.askyesno(title, text))
#         except Exception:
#             pass
#     _r1840_log("ASK-YESNO [" + str(title) + "]: " + str(text) + " -> fallback=True")
#     return True
# 
# 
# def _r1840_ask_string(title, prompt, initial=""):
#     if _r1840_simpledialog is not None:
#         try:
#             return _r1840_simpledialog.askstring(title, prompt, initialvalue=initial)
#         except Exception:
#             pass
#     _r1840_log("ASK-STRING [" + str(title) + "]: " + str(prompt) + " (kein Dialog verfuegbar)")
#     return None
# 
# 
# def _r1840_get_undo_stack(app):
#     """Liefert den Undo-Stack fuer Tree-Aktionen (Liste) am App-Objekt."""
#     stack = getattr(app, "_tree_undo_stack", None)
#     if not isinstance(stack, list):
#         stack = []
#         try:
#             app._tree_undo_stack = stack
#         except Exception:
#             pass
#     return stack
# 
# 
# def _r1840_get_selected_path(app):
#     """Ermittelt den Pfad der markierten Datei in der rechten Liste.
# 
#     Bevorzugt ui_project_tree.get_selected_path(app).
#     """
#     # 1) ui_project_tree.get_selected_path(app)
#     try:
#         from modules import ui_project_tree as _r1840_uipt
#         try:
#             path = _r1840_uipt.get_selected_path(app)
#             if path:
#                 return path
#         except Exception:
#             pass
#     except Exception:
#         pass
# 
#     # 2) Fallback ueber app.tree_paths
#     tree = getattr(app, "tree", None)
#     paths = getattr(app, "tree_paths", {})
#     try:
#         if tree is not None:
#             sel = tree.selection()
#         else:
#             sel = []
#     except Exception:
#         sel = []
#     if not sel:
#         return None
#     iid = sel[0]
#     return paths.get(iid)
# 
# 
# def _r1840_refresh_right_list(app):
#     """Aktualisiert die rechte Liste / den Tree, ohne Exceptions nach aussen."""
#     try:
#         proxy = getattr(app, "right_list", None)
#         if proxy is not None and hasattr(proxy, "refresh"):
#             proxy.refresh()
#             return
#     except Exception:
#         pass
#     # Fallback: nichts tun
# 
# 
# def _r1840_make_trash_name(path):
#     """Erzeugt Soft-Delete-Zielnamen im selben Ordner.
# 
#     Beispiel:
#         R1839.py -> .__deleted_R1840_20251130_183000__R1839.py
#     """
#     folder = _r1840_os.path.dirname(path)
#     base = _r1840_os.path.basename(path)
#     ts = _r1840_time.strftime("%Y%m%d_%H%M%S")
#     name = ".__deleted_R1840_" + ts + "__" + base
#     candidate = _r1840_os.path.join(folder, name)
#     counter = 1
#     while _r1840_os.path.exists(candidate):
#         name2 = ".__deleted_R1840_" + ts + "_" + str(counter) + "__" + base
#         candidate = _r1840_os.path.join(folder, name2)
#         counter += 1
#     return candidate
# 
# 
# def action_tree_delete(app, *args, **kwargs):
#     """Soft Delete fuer markierte Datei in der rechten Liste.
# 
#     Umsetzung:
#     - Pfad ermitteln
#     - Bestaetigung einholen
#     - Datei in Trash-Namen im selben Ordner umbenennen
#     - Undo-Stack-Eintrag anlegen
#     - rechte Liste aktualisieren
#     """
#     try:
#         path = _r1840_get_selected_path(app)
#         if not path:
#             _r1840_msg_info("Loeschen", "Bitte zuerst eine Datei in der rechten Liste markieren.")
#             return
# 
#         if not _r1840_os.path.exists(path):
#             _r1840_msg_error("Loeschen", "Die Datei existiert nicht mehr auf dem Datentraeger.")
#             return
# 
#         ok = _r1840_msg_yesno("Loeschen", "Datei wirklich loeschen (Soft Delete)?\n\n" + str(path))
#         if not ok:
#             return
# 
#         trash = _r1840_make_trash_name(path)
#         _r1840_os.rename(path, trash)
# 
#         stack = _r1840_get_undo_stack(app)
#         entry = {
#             "action": "delete",
#             "original": path,
#             "trash": trash,
#             "time": _r1840_time.time(),
#         }
#         stack.append(entry)
#         _r1840_log("Delete: " + path + " -> " + trash)
# 
#         _r1840_refresh_right_list(app)
# 
#     except Exception as exc:
#         _r1840_msg_error("Loeschen", "Fehler beim Loeschen: " + repr(exc))
# 
# 
# def action_tree_rename(app, *args, **kwargs):
#     """Markierte Datei in der rechten Liste umbenennen (undo-faehig)."""
#     try:
#         path = _r1840_get_selected_path(app)
#         if not path:
#             _r1840_msg_info("Rename", "Bitte zuerst eine Datei in der rechten Liste markieren.")
#             return
# 
#         folder = _r1840_os.path.dirname(path)
#         old_name = _r1840_os.path.basename(path)
# 
#         new_name = _r1840_ask_string("Rename", "Neuer Dateiname (ohne Pfad):", old_name)
#         if not new_name:
#             return
#         new_name = str(new_name).strip()
#         if not new_name:
#             return
# 
#         new_path = _r1840_os.path.join(folder, new_name)
#         if _r1840_os.path.exists(new_path):
#             _r1840_msg_error("Rename", "Es existiert bereits eine Datei mit diesem Namen.")
#             return
# 
#         _r1840_os.rename(path, new_path)
# 
#         stack = _r1840_get_undo_stack(app)
#         entry = {
#             "action": "rename",
#             "old_path": path,
#             "new_path": new_path,
#             "time": _r1840_time.time(),
#         }
#         stack.append(entry)
#         _r1840_log("Rename: " + path + " -> " + new_path)
# 
#         _r1840_refresh_right_list(app)
# 
#     except Exception as exc:
#         _r1840_msg_error("Rename", "Fehler beim Umbenennen: " + repr(exc))
# 
# 
# def action_tree_undo(app, *args, **kwargs):
#     """Letzte Tree-Aktion (delete/rename) rueckgaengig machen."""
#     try:
#         stack = _r1840_get_undo_stack(app)
#         if not stack:
#             _r1840_msg_info("Undo", "Kein Undo-Eintrag vorhanden.")
#             return
# 
#         entry = stack.pop()
#         kind = entry.get("action")
# 
#         if kind == "delete":
#             orig = entry.get("original")
#             trash = entry.get("trash")
#             if trash and _r1840_os.path.exists(trash):
#                 if orig and not _r1840_os.path.exists(orig):
#                     _r1840_os.rename(trash, orig)
#                     _r1840_log("Undo Delete: " + trash + " -> " + orig)
#                 else:
#                     _r1840_msg_error("Undo Loeschen", "Originalpfad ist bereits belegt, Undo abgebrochen.")
#                     stack.append(entry)
#                     return
#             else:
#                 _r1840_msg_info("Undo Loeschen", "Trash-Datei existiert nicht mehr, nichts zu tun.")
# 
#         elif kind == "rename":
#             old_path = entry.get("old_path")
#             new_path = entry.get("new_path")
#             if new_path and _r1840_os.path.exists(new_path):
#                 if old_path and not _r1840_os.path.exists(old_path):
#                     _r1840_os.rename(new_path, old_path)
#                     _r1840_log("Undo Rename: " + new_path + " -> " + old_path)
#                 else:
#                     _r1840_msg_error("Undo Rename", "Alter Pfad ist bereits belegt, Undo abgebrochen.")
#                     stack.append(entry)
#                     return
#             else:
#                 _r1840_msg_info("Undo Rename", "Neue Datei existiert nicht mehr, nichts zu tun.")
# 
#         else:
#             _r1840_msg_info("Undo", "Unbekannte Aktion: " + str(kind))
# 
#         _r1840_refresh_right_list(app)
# 
#     except Exception as exc:
#         _r1840_msg_error("Undo", "Fehler beim Undo: " + repr(exc))
# 
# # R1840_END_TOOLBAR_ACTIONS
# 
# 
# 

# --- LEGACY_R2032: R1841_TOOLBAR_TRASH ---
# 
# 
# 
# # R1841_START_TOOLBAR_TRASH
# # [DEPRECATED_PHASE1_R2027]: Papierkorb-Variante alt – ueberlagert durch R1841B.
# # ToolbarRightFix (Papierkorb) - automatische Ergänzung durch R1841
# #
# # Diese Implementierung ueberschreibt action_tree_delete aus R1840:
# # - Datei wandert in ShrimpDev-Papierkorb (_Trash im Projektroot)
# # - Undo verwendet unverändert den bestehenden R1840-Mechanismus.
# 
# import os as _r1841_os
# import time as _r1841_time
# 
# try:
#     import tkinter as _r1841_tk
#     from tkinter import messagebox as _r1841_messagebox
# except Exception:
#     _r1841_tk = None
#     _r1841_messagebox = None
# 
# 
# def _r1841_msg_info(title, text):
#     if _r1841_messagebox is not None:
#         try:
#             _r1841_messagebox.showinfo(title, text)
#             return
#         except Exception:
#             pass
#     # Fallback: nur Log (falls vorhanden)
#     try:
#         from modules.logic_actions import log_debug as _r1841_log_debug  # type: ignore
#         _r1841_log_debug("[R1841-INFO] " + str(title) + ": " + str(text))
#     except Exception:
#         pass
# 
# 
# def _r1841_msg_error(title, text):
#     if _r1841_messagebox is not None:
#         try:
#             _r1841_messagebox.showerror(title, text)
#             return
#         except Exception:
#             pass
#     try:
#         from modules.logic_actions import log_debug as _r1841_log_debug  # type: ignore
#         _r1841_log_debug("[R1841-ERROR] " + str(title) + ": " + str(text))
#     except Exception:
#         pass
# 
# 
# def _r1841_msg_yesno(title, text):
#     if _r1841_messagebox is not None:
#         try:
#             return bool(_r1841_messagebox.askyesno(title, text))
#         except Exception:
#             pass
#     # Fallback: lieber True als blockieren
#     try:
#         from modules.logic_actions import log_debug as _r1841_log_debug  # type: ignore
#         _r1841_log_debug("[R1841-ASK-YESNO] " + str(title) + ": " + str(text) + " -> fallback=True")
#     except Exception:
#         pass
#     return True
# 
# 
# def _r1841_get_root_dir():
#     try:
#         here = _r1841_os.path.abspath(_r1841_os.path.dirname(__file__))
#         return _r1841_os.path.abspath(_r1841_os.path.join(here, ".."))
#     except Exception:
#         return None
# 
# 
# def _r1841_get_trash_dir():
#     root = _r1841_get_root_dir()
#     if not root:
#         return None
#     trash = _r1841_os.path.join(root, "_Trash")
#     try:
#         if not _r1841_os.path.isdir(trash):
#             _r1841_os.makedirs(trash)
#     except Exception:
#         pass
#     return trash
# 
# 
# def _r1841_get_undo_stack(app):
#     stack = getattr(app, "_tree_undo_stack", None)
#     if not isinstance(stack, list):
#         stack = []
#         try:
#             app._tree_undo_stack = stack
#         except Exception:
#             pass
#     return stack
# 
# 
# def _r1841_get_selected_path(app):
#     # Bevorzugt ui_project_tree.get_selected_path(app)
#     try:
#         from modules import ui_project_tree as _r1841_uipt  # type: ignore
#         try:
#             path = _r1841_uipt.get_selected_path(app)
#             if path:
#                 return path
#         except Exception:
#             pass
#     except Exception:
#         pass
# 
#     # Fallback ueber tree/tree_paths
#     tree = getattr(app, "tree", None)
#     paths = getattr(app, "tree_paths", {})
#     try:
#         if tree is not None:
#             sel = tree.selection()
#         else:
#             sel = []
#     except Exception:
#         sel = []
#     if not sel:
#         return None
#     iid = sel[0]
#     return paths.get(iid)
# 
# 
# def _r1841_refresh_right_list(app):
#     try:
#         proxy = getattr(app, "right_list", None)
#         if proxy is not None and hasattr(proxy, "refresh"):
#             proxy.refresh()
#     except Exception:
#         pass
# 
# 
# def _r1841_move_to_trash(path):
#     """Verschiebt die Datei in den ShrimpDev-Papierkorb und gibt den Trash-Pfad zurueck."""
#     trash_root = _r1841_get_trash_dir()
#     if not trash_root:
#         return None
#     base = _r1841_os.path.basename(path)
#     ts = _r1841_time.strftime("%Y%m%d_%H%M%S")
#     name = ts + "__" + base
#     dest = _r1841_os.path.join(trash_root, name)
#     counter = 1
#     while _r1841_os.path.exists(dest):
#         dest = _r1841_os.path.join(trash_root, ts + "_" + str(counter) + "__" + base)
#         counter += 1
#     _r1841_os.rename(path, dest)
#     return dest
# 
# 
# def action_tree_delete(app, *args, **kwargs):
#     """Loeschen fuer rechte Liste: Datei wandert in den ShrimpDev-Papierkorb (_Trash).
# 
#     Undo verwendet den bestehenden Mechanismus:
#     - Stack-Eintrag mit action='delete', original=<orig>, trash=<trash>
#     """
#     try:
#         path = _r1841_get_selected_path(app)
#         if not path:
#             _r1841_msg_info("Loeschen", "Bitte zuerst eine Datei in der rechten Liste markieren.")
#             return
# 
#         if not _r1841_os.path.exists(path):
#             _r1841_msg_error("Loeschen", "Die Datei existiert nicht mehr auf dem Datentraeger.")
#             return
# 
#         text = "Datei in den ShrimpDev-Papierkorb verschieben?\n\n" + str(path)
#         ok = _r1841_msg_yesno("Loeschen", text)
#         if not ok:
#             return
# 
#         trash = _r1841_move_to_trash(path)
#         if not trash:
#             _r1841_msg_error("Loeschen", "Papierkorb (_Trash) konnte nicht verwendet werden.")
#             return
# 
#         stack = _r1841_get_undo_stack(app)
#         entry = {
#             "action": "delete",
#             "original": path,
#             "trash": trash,
#             "time": _r1841_time.time(),
#         }
#         stack.append(entry)
# 
#         _r1841_refresh_right_list(app)
#         _r1841_msg_info("Loeschen", "Datei wurde in den ShrimpDev-Papierkorb verschoben.")
# 
#     except Exception as exc:
#         _r1841_msg_error("Loeschen", "Fehler beim Loeschen: " + repr(exc))
# 
# # R1841_END_TOOLBAR_TRASH
# 
# 
# 

# --- LEGACY_R2032: R1846_RUNNER_POPUP ---
# # R1846_START_RUNNER_POPUP
# # [DEPRECATED_PHASE1_R2027]: Runner-Popup-System alt – ueberlagert durch neuere Popup-Implementierungen.
# # Re-Implementierung der SonderRunner-Ausführung in GUI-Popup
# 
# import subprocess as _r1846_sub
# import threading as _r1846_thread
# 
# try:
#     import tkinter as _r1846_tk
#     from tkinter import messagebox as _r1846_mb
# except Exception:
#     _r1846_tk = None
#     _r1846_mb = None
# 
# 
# def _r1846_show_popup(title, text):
#     """Zentrales Popup für Runner-Ausgaben."""
#     if _r1846_tk is None:
#         return
#     try:
#         win = _r1846_tk.Toplevel()
#         win.title(title)
#         win.geometry("700x600")
#         win.grab_set()
# 
#         txt = _r1846_tk.Text(win, wrap="word")
#         txt.pack(expand=True, fill="both")
#         txt.insert("1.0", text)
#         txt.config(state="disabled")
# 
#         btn = _r1846_tk.Button(win, text="Schließen", command=win.destroy)
#         btn.pack(pady=8)
# 
#     except Exception as exc:
#         try:
#             _r1846_mb.showinfo(title, text)
#         except:
#             pass
# 
# 
# def _r1846_run_cmd_in_background(app, cmd_path, label):
#     """Startet CMD im Hintergrund und zeigt Ausgabe im Popup."""
# 
#     def worker():
#         try:
#             proc = _r1846_sub.Popen(
#                 ["cmd", "/c", cmd_path],
#                 stdout=_r1846_sub.PIPE,
#                 stderr=_r1846_sub.PIPE,
#                 text=True
#             )
#             out, err = proc.communicate()
#             txt = ""
#             if out:
#                 txt += out
#             if err:
#                 txt += "\n--- STDERR ---\n" + err
# 
#             title = f"{label} – Ausgabe"
#             _r1846_show_popup(title, txt)
# 
#         except Exception as exc:
#             _r1846_show_popup(label, "Fehler beim Ausführen:\n" + repr(exc))
# 
#     _r1846_thread.Thread(target=worker, daemon=True).start()
# 
# 
# def _r1846_run_tools_runner(app, runner_id, label):
#     import os as _os
#     root_dir = _os.path.abspath(_os.path.join(_os.path.dirname(__file__), ".."))
#     tools_dir = _os.path.join(root_dir, "tools")
#     cmd_path = _os.path.join(tools_dir, runner_id + ".cmd")
# 
#     if not _os.path.isfile(cmd_path):
#         if _r1846_mb:
#             try:
#                 _r1846_mb.showerror(label, "Runner-Datei nicht gefunden:\n" + cmd_path)
#                 return
#             except:
#                 pass
#         return
# 
#     # jetzt GUI-Output statt externem Terminal
#     _r1846_run_cmd_in_background(app, cmd_path, label)
# 
# # override alte Funktionen
# action_guard_futurefix        = lambda app, *a, **k: _r1846_run_tools_runner(app, "R9997", "FutureFix")
# action_guard_futurefix_safe   = lambda app, *a, **k: _r1846_run_tools_runner(app, "R1351", "FutureFix Safe")
# action_r9998                  = lambda app, *a, **k: _r1846_run_tools_runner(app, "R9998", "Build Tools")
# action_r9999                  = lambda app, *a, **k: _r1846_run_tools_runner(app, "R9999", "Diagnose")
# 
# # R1846_END_RUNNER_POPUP
# 
# 
# 

# --- LEGACY_R2032: R1847_SONDERRUNNER_POPUP ---
# 
# 
# 
# # R1847_START_SONDERRUNNER_POPUP
# # [DEPRECATED_PHASE1_R2027]: Runner-Popup-System alt – ueberlagert durch neuere Popup-Implementierungen.
# # SonderRunner-Ausgabe (R9997/R1351/R9998/R9999) in GUI-Popup umleiten.
# 
# import os as _r1847_os
# import subprocess as _r1847_sub
# import threading as _r1847_thread
# 
# try:
#     import tkinter as _r1847_tk
#     from tkinter import messagebox as _r1847_mb
# except Exception:
#     _r1847_tk = None
#     _r1847_mb = None
# 
# 
# def _r1847_show_popup(title, text):
#     """Zentrales Popup-Fenster zur Anzeige von Runner-Ausgaben."""
#     if _r1847_tk is None:
#         # kein Tk-Kontext verfügbar
#         return
#     try:
#         win = _r1847_tk.Toplevel()
#         win.title(title)
#         win.geometry("900x600")
#         win.grab_set()
# 
#         frame = _r1847_tk.Frame(win)
#         frame.pack(expand=True, fill="both")
# 
#         scrollbar = _r1847_tk.Scrollbar(frame)
#         scrollbar.pack(side="right", fill="y")
# 
#         txt = _r1847_tk.Text(frame, wrap="word")
#         txt.pack(side="left", expand=True, fill="both")
#         txt.config(yscrollcommand=scrollbar.set)
#         scrollbar.config(command=txt.yview)
# 
#         txt.insert("1.0", text or "(keine Ausgabe)")
#         txt.config(state="disabled")
# 
#         btn = _r1847_tk.Button(win, text="Schließen", command=win.destroy)
#         btn.pack(pady=6)
# 
#     except Exception as exc:
#         # Fallback auf einfache Messagebox
#         if _r1847_mb is not None:
#             try:
#                 _r1847_mb.showinfo(title, text)
#             except Exception:
#                 pass
# 
# 
# def _r1847_run_cmd_in_background(cmd_path, label):
#     """Startet cmd_path im Hintergrund und zeigt Ausgabe in Popup."""
# 
#     def worker():
#         try:
#             proc = _r1847_sub.Popen(
#                 ["cmd", "/c", cmd_path],
#                 stdout=_r1847_sub.PIPE,
#                 stderr=_r1847_sub.PIPE,
#                 text=True
#             )
#             out, err = proc.communicate()
# 
#             lines = []
#             lines.append("Runner: " + cmd_path)
#             lines.append("Label : " + label)
#             lines.append("Exit  : " + str(proc.returncode))
#             lines.append("")
#             if out:
#                 lines.append("--- STDOUT ---")
#                 lines.append(out)
#             if err:
#                 lines.append("")
#                 lines.append("--- STDERR ---")
#                 lines.append(err)
# 
#             text = "\n".join(lines)
#             _r1847_show_popup(label + " – Ausgabe", text)
# 
#         except Exception as exc:
#             _r1847_show_popup(label, "Fehler beim Ausführen:\n" + repr(exc))
# 
#     _r1847_thread.Thread(target=worker, daemon=True).start()
# 
# 
# def _r1847_run_tools_runner(app, runner_id, label):
#     """Ermittelt tools\\<runner_id>.cmd und startet es über das Popup-System."""
#     root_dir = _r1847_os.path.abspath(_r1847_os.path.join(_r1847_os.path.dirname(__file__), ".."))
#     tools_dir = _r1847_os.path.join(root_dir, "tools")
#     cmd_path = _r1847_os.path.join(tools_dir, runner_id + ".cmd")
# 
#     if not _r1847_os.path.isfile(cmd_path):
#         msg = "Runner-Datei nicht gefunden:\n" + cmd_path
#         if _r1847_mb is not None:
#             try:
#                 _r1847_mb.showerror(label, msg)
#                 return
#             except Exception:
#                 pass
#         _r1847_show_popup(label, msg)
#         return
# 
#     _r1847_run_cmd_in_background(cmd_path, label)
# 
# 
# # Bestehende Actions aus R1845 ueberschreiben:
# def action_guard_futurefix(app, *args, **kwargs):      # type: ignore[override]
#     _r1847_run_tools_runner(app, "R9997", "FutureFix")
# 
# 
# def action_guard_futurefix_safe(app, *args, **kwargs):  # type: ignore[override]
#     _r1847_run_tools_runner(app, "R1351", "FutureFix Safe")
# 
# 
# def action_r9998(app, *args, **kwargs):                 # type: ignore[override]
#     _r1847_run_tools_runner(app, "R9998", "Build Tools")
# 
# 
# def action_r9999(app, *args, **kwargs):                 # type: ignore[override]
#     _r1847_run_tools_runner(app, "R9999", "Diagnose")
# 
# # R1847_END_SONDERRUNNER_POPUP
# 
# 

# --- LEGACY_R2032: R1849_POPUP_ENHANCED ---
# 
# 
# # R1849_START_POPUP_ENHANCED
# # [DEPRECATED_PHASE1_R2027]: Runner-Popup-System alt – ueberlagert durch INI-basierte RunnerPopups.
# # Verbesserte Popup-Ausgabe fuer SonderRunner (Monospace, Copy, Save)
# 
# import os as _r1849_os
# 
# try:
#     import tkinter as _r1849_tk
#     from tkinter import messagebox as _r1849_mb
#     import tkinter.font as _r1849_font
# except Exception:
#     _r1849_tk = None
#     _r1849_mb = None
#     _r1849_font = None
# 
# def _r1849_get_root_dir():
#     try:
#         here = _r1849_os.path.abspath(_r1849_os.path.dirname(__file__))
#         return _r1849_os.path.abspath(_r1849_os.path.join(here, ".."))
#     except Exception:
#         return None
# 
# def _r1849_save_to_file(title, text):
#     root = _r1849_get_root_dir()
#     if not root:
#         return None
#     reports = _r1849_os.path.join(root, "_Reports")
#     try:
#         _r1849_os.makedirs(reports, exist_ok=True)
#     except Exception:
#         return None
#     ts = __import__("time").strftime("%Y%m%d_%H%M%S")
#     safe_title = "".join(ch if ch.isalnum() or ch in ("_", "-", ".") else "_" for ch in str(title))
#     filename = f"RunnerOutput_{ts}_{safe_title}.txt"
#     path = _r1849_os.path.join(reports, filename)
#     try:
#         with open(path, "w", encoding="utf-8") as f:
#             f.write(text or "")
#         return path
#     except Exception:
#         return None
# 
# def _r1847_show_popup(title, text):
#     """Zentrales Popup fuer Runner-Ausgaben (verbessert durch R1849)."""
#     if _r1849_tk is None:
#         return
#     content = text or "(keine Ausgabe)"
#     try:
#         win = _r1849_tk.Toplevel()
#         win.title(str(title))
#         win.geometry("900x600")
#         win.grab_set()
# 
#         frame = _r1849_tk.Frame(win)
#         frame.pack(expand=True, fill="both")
# 
#         scrollbar = _r1849_tk.Scrollbar(frame)
#         scrollbar.pack(side="right", fill="y")
# 
#         txt = _r1849_tk.Text(frame, wrap="word")
#         txt.pack(side="left", expand=True, fill="both")
#         txt.config(yscrollcommand=scrollbar.set)
#         scrollbar.config(command=txt.yview)
# 
#         if _r1849_font is not None:
#             try:
#                 mono = _r1849_font.Font(family="Courier New", size=10)
#                 txt.configure(font=mono)
#             except Exception:
#                 pass
# 
#         txt.insert("1.0", content)
#         txt.config(state="normal")
# 
#         # Button-Leiste
#         btn_frame = _r1849_tk.Frame(win)
#         btn_frame.pack(fill="x", pady=4)
# 
#         def _copy_to_clipboard():
#             try:
#                 win.clipboard_clear()
#                 win.clipboard_append(content)
#                 if _r1849_mb:
#                     try:
#                         _r1849_mb.showinfo("Kopiert", "Ausgabe wurde in die Zwischenablage kopiert.")
#                     except Exception:
#                         pass
#             except Exception:
#                 pass
# 
#         def _save_to_file():
#             path = _r1849_save_to_file(title, content)
#             if not path:
#                 if _r1849_mb:
#                     try:
#                         _r1849_mb.showerror("Speichern", "Datei konnte nicht gespeichert werden.")
#                     except Exception:
#                         pass
#                 return
#             if _r1849_mb:
#                 try:
#                     _r1849_mb.showinfo("Gespeichert", "Datei gespeichert unter:\n" + path)
#                 except Exception:
#                     pass
# 
#         btn_copy = _r1849_tk.Button(btn_frame, text="In Zwischenablage", command=_copy_to_clipboard)
#         btn_copy.pack(side="left", padx=4)
# 
#         btn_save = _r1849_tk.Button(btn_frame, text="Als Datei speichern", command=_save_to_file)
#         btn_save.pack(side="left", padx=4)
# 
#         btn_close = _r1849_tk.Button(btn_frame, text="Schliessen", command=win.destroy)
#         btn_close.pack(side="right", padx=4)
# 
#     except Exception as exc:
#         if _r1849_mb is not None:
#             try:
#                 _r1849_mb.showinfo(str(title), content)
#             except Exception:
#                 pass
# 
# # R1849_END_POPUP_ENHANCED
# 
# 


# ============================================================
# R2066_TREE_RENAME_UNDO_START
# Echte Implementierung für Tree-Rename und Tree-Undo.
# Nutzt _tree_undo_stack wie action_tree_delete und ruft,
# falls vorhanden, _r2065_safe_led_evaluate(app) für LED-Refresh.
# ============================================================

import os as _r2066_os
import time as _r2066_time

try:
    import tkinter as _r2066_tk
    from tkinter import messagebox as _r2066_mb
    from tkinter import simpledialog as _r2066_sd
except Exception:
    _r2066_tk = None
    _r2066_mb = None
    _r2066_sd = None


def _r2066_status(app, msg: str) -> None:
    try:
        if "_rR1837_status" in globals():
            try:
                _rR1837_status(app, msg)  # type: ignore[name-defined]
                return
            except Exception:
                pass
    except Exception:
        pass
    try:
        if "_status" in globals():
            try:
                _status(app, msg)  # type: ignore[name-defined]
                return
            except Exception:
                pass
    except Exception:
        pass
    try:
        print("[R2066]", msg)
    except Exception:
        pass


def _r2066_get_undo_stack(app):
    stack = getattr(app, "_tree_undo_stack", None)
    if not isinstance(stack, list):
        stack = []
        try:
            app._tree_undo_stack = stack
        except Exception:
            pass
    return stack


def _r2066_get_selected_path(app):
    try:
        from modules import ui_project_tree as _r2066_uipt  # type: ignore
    except Exception:
        _r2066_uipt = None  # type: ignore[assignment]

    if _r2066_uipt is not None:
        try:
            path = _r2066_uipt.get_selected_path(app)
            if path:
                return path
        except Exception:
            pass

    tree = getattr(app, "tree", None)
    paths = getattr(app, "tree_paths", {})
    try:
        sel = tree.selection() if tree is not None else []
    except Exception:
        sel = []
    if not sel:
        return None
    iid = sel[0]
    return paths.get(iid)


def _r2066_refresh_right_list(app) -> None:
    try:
        proxy = getattr(app, "right_list", None)
        if proxy is not None and hasattr(proxy, "refresh"):
            proxy.refresh()
    except Exception:
        pass


def _r2066_safe_led_eval(app) -> None:
    try:
        if "_r2065_safe_led_evaluate" in globals():
            try:
                _r2065_safe_led_evaluate(app)  # type: ignore[name-defined]
            except Exception:
                pass
    except Exception:
        pass


def action_tree_rename(app, *args, **kwargs):  # type: ignore[override]
    path = _r2066_get_selected_path(app)
    if not path:
        if _r2066_mb is not None:
            try:
                _r2066_mb.showinfo("Rename", "Bitte zuerst eine Datei in der rechten Liste markieren.")
            except Exception:
                pass
        _r2066_status(app, "Rename: keine Datei ausgewählt.")
        return

    if not _r2066_os.path.exists(path):
        if _r2066_mb is not None:
            try:
                _r2066_mb.showerror("Rename", "Die Datei existiert nicht mehr auf dem Datenträger.")
            except Exception:
                pass
        _r2066_status(app, "Rename: Datei existiert nicht mehr.")
        return

    folder = _r2066_os.path.dirname(path)
    old_name = _r2066_os.path.basename(path)

    new_name = None
    if _r2066_sd is not None:
        try:
            new_name = _r2066_sd.askstring("Rename", "Neuer Dateiname (ohne Pfad):", initialvalue=old_name, parent=app)
        except Exception:
            new_name = None

    if not new_name:
        _r2066_status(app, "Rename abgebrochen.")
        return

    new_name = str(new_name).strip()
    if not new_name or new_name == old_name:
        _r2066_status(app, "Rename: kein neuer Name angegeben.")
        return

    new_path = _r2066_os.path.join(folder, new_name)
    if _r2066_os.path.exists(new_path):
        if _r2066_mb is not None:
            try:
                _r2066_mb.showerror("Rename", "Es existiert bereits eine Datei mit diesem Namen.")
            except Exception:
                pass
        _r2066_status(app, "Rename: Zielname existiert bereits.")
        return

    try:
        _r2066_os.rename(path, new_path)
    except Exception as exc:
        if _r2066_mb is not None:
            try:
                _r2066_mb.showerror("Rename", "Fehler beim Umbenennen:\n" + repr(exc))
            except Exception:
                pass
        _r2066_status(app, "Rename fehlgeschlagen: " + repr(exc))
        return

    stack = _r2066_get_undo_stack(app)
    stack.append({
        "action": "rename",
        "old_path": path,
        "new_path": new_path,
        "time": _r2066_time.time(),
    })

    _r2066_status(app, "Umbenannt: " + old_name + " -> " + new_name)
    _r2066_refresh_right_list(app)
    _r2066_safe_led_eval(app)


def action_tree_undo(app, *args, **kwargs):  # type: ignore[override]
    stack = _r2066_get_undo_stack(app)
    if not stack:
        if _r2066_mb is not None:
            try:
                _r2066_mb.showinfo("Undo", "Kein Undo-Eintrag vorhanden.")
            except Exception:
                pass
        _r2066_status(app, "Undo: kein Eintrag vorhanden.")
        return

    entry = stack.pop()
    kind = entry.get("action")

    try:
        if kind == "delete":
            orig = entry.get("original")
            trash = entry.get("trash")
            if trash and _r2066_os.path.exists(trash):
                if orig and not _r2066_os.path.exists(orig):
                    _r2066_os.rename(trash, orig)
                    _r2066_status(app, "Undo Delete: Datei wiederhergestellt.")
                else:
                    _r2066_status(app, "Undo Delete: Originalpfad belegt, Undo abgebrochen.")
                    stack.append(entry)
                    return
            else:
                _r2066_status(app, "Undo Delete: Trash-Datei existiert nicht mehr.")

        elif kind == "rename":
            old_path = entry.get("old_path")
            new_path = entry.get("new_path")
            if new_path and _r2066_os.path.exists(new_path):
                if old_path and not _r2066_os.path.exists(old_path):
                    _r2066_os.rename(new_path, old_path)
                    _r2066_status(app, "Undo Rename: Dateiname wiederhergestellt.")
                else:
                    _r2066_status(app, "Undo Rename: alter Pfad belegt, Undo abgebrochen.")
                    stack.append(entry)
                    return
            else:
                _r2066_status(app, "Undo Rename: neue Datei existiert nicht mehr.")

        else:
            _r2066_status(app, "Undo: unbekannte Aktion " + str(kind))

    except Exception as exc:
        _r2066_status(app, "Undo: Fehler " + repr(exc))

    _r2066_refresh_right_list(app)
    _r2066_safe_led_eval(app)

# R2066_TREE_RENAME_UNDO_END
# ============================================================


# ------------------------------------------------------------------
# Tools Purge Actions (ROOT-only; no subfolders)
# Added by R2212 (EOF-only)
# ------------------------------------------------------------------
def action_tools_purge_scan(app, *args, **kwargs):  # type: ignore
    # Erstellt Plan: docs\Tools_Purge_Flat_Plan.md (nur tools\ Root-Dateien)
    _r1851_run_tools_runner(app, "R2218", "Tools Purge Scan")

def action_tools_purge_apply(app, *args, **kwargs):  # type: ignore
    # Verschiebt NUR Dateien direkt in tools\ nach tools\Archiv (laut Plan). Subfolder werden NICHT angefasst.
    if _r1851_mb is not None:
        ok = _r1851_mb.askyesno(
            "Tools Purge Apply",
            "Wirklich Purge APPLY ausfuehren?\n\n"
            "- betrifft nur tools\\ (ROOT-Dateien)\n"
            "- Subfolder werden NICHT angefasst\n"
            "- Basis: docs\\Tools_Purge_Flat_Plan.md\n",
        )
        if not ok:
            return
    _r1851_run_tools_runner(app, "R2224", "Tools Purge Apply")
