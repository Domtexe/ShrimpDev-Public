# file: tools/R2218.py
from __future__ import annotations

import re
from dataclasses import dataclass
from pathlib import Path
from datetime import datetime

RID = "R2218"

ROOT = Path(__file__).resolve().parents[1]
TOOLS = ROOT / "tools"
DOCS = ROOT / "docs"
REPORTS = ROOT / "_Reports"

PLAN_PATH = DOCS / "Tools_Purge_Flat_Plan.md"
KEEP_LAST_N = 20  # Sicherheits-Puffer: die letzten 20 (mtime) bleiben IMMER

RX = re.compile(r"^R(\d{4})\.(py|cmd)$", re.IGNORECASE)

def ts() -> str:
    return datetime.now().strftime("%Y%m%d_%H%M%S")

def fmt_dt(epoch: float | None) -> str:
    if epoch is None:
        return "—"
    try:
        return datetime.fromtimestamp(epoch).strftime("%Y-%m-%d %H:%M:%S")
    except Exception:
        return "n/a"

@dataclass
class RunnerPair:
    rid: int
    py: Path | None
    cmd: Path | None
    mtime: float
    py_mtime: float | None
    cmd_mtime: float | None

def scan_tools_root_pairs(tools_dir: Path) -> dict[int, RunnerPair]:
    pairs: dict[int, RunnerPair] = {}
    for p in tools_dir.iterdir():
        if not p.is_file():
            continue
        m = RX.match(p.name)
        if not m:
            continue
        rid = int(m.group(1))
        ext = m.group(2).lower()
        mt = p.stat().st_mtime

        if rid not in pairs:
            pairs[rid] = RunnerPair(rid=rid, py=None, cmd=None, mtime=mt, py_mtime=None, cmd_mtime=None)

        rp = pairs[rid]
        if ext == "py":
            rp.py = p
            rp.py_mtime = mt
        else:
            rp.cmd = p
            rp.cmd_mtime = mt

        rp.mtime = max([x for x in [rp.py_mtime, rp.cmd_mtime] if x is not None] or [rp.mtime])

    return pairs

def load_keep_set(root: Path) -> set[int]:
    keep: set[int] = set()
    keep_path = root / "registry" / "tools_keep.txt"
    if keep_path.exists():
        for line in keep_path.read_text(encoding="utf-8", errors="replace").splitlines():
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            m = re.search(r"R(\d{4})", line)
            if m:
                keep.add(int(m.group(1)))
    return keep

def main() -> int:
    REPORTS.mkdir(exist_ok=True)
    DOCS.mkdir(exist_ok=True)

    report_path = REPORTS / f"{RID}_Tools_Purge_Flat_Scan_v3_{ts()}.txt"
    report: list[str] = []

    print("=" * 72)
    print(f"[{RID}] Tools Purge Flat Scan v3 (mtime-based KEEP last {KEEP_LAST_N}, ROOT ONLY)")
    print("Anchor: newest by mtime of .cmd/.py (pair-aware, robust)")
    print("=" * 72)

    if not TOOLS.exists():
        msg = f"[ABORT] tools dir not found: {TOOLS}"
        print(msg); report.append(msg)
        report_path.write_text("\n".join(report) + "\n", encoding="utf-8")
        return 2

    pairs = scan_tools_root_pairs(TOOLS)
    if not pairs:
        msg = "[ABORT] No runner files found in tools root."
        print(msg); report.append(msg)
        report_path.write_text("\n".join(report) + "\n", encoding="utf-8")
        return 2

    # Anchor by mtime
    newest = sorted(pairs.values(), key=lambda r: (r.mtime, r.rid), reverse=True)[0]
    anchor_id = newest.rid

    keep_ids = load_keep_set(ROOT)

    # Safety buffer: newest N by mtime always KEEP
    newest_ids = [rp.rid for rp in sorted(pairs.values(), key=lambda r: (r.mtime, r.rid), reverse=True)[:KEEP_LAST_N]]
    keep_ids |= set(newest_ids)

    # classify
    keep: list[RunnerPair] = []
    archive: list[RunnerPair] = []
    for rid, rp in sorted(pairs.items(), key=lambda kv: kv[0]):
        if rid in keep_ids:
            keep.append(rp)
        else:
            archive.append(rp)

    def row(rp: RunnerPair) -> str:
        flags = []
        if rp.py is None: flags.append("MISSING_PY")
        if rp.cmd is None: flags.append("MISSING_CMD")
        f = (" [" + ",".join(flags) + "]") if flags else ""
        return (
            f"- R{rp.rid:04d}{f}  "
            f"(pair_mtime: {fmt_dt(rp.mtime)}, py: {fmt_dt(rp.py_mtime)}, cmd: {fmt_dt(rp.cmd_mtime)})\n"
        )

    md: list[str] = []
    md.append("# Tools Purge Flat Plan (ROOT ONLY, no subfolders)\n")
    md.append(f"- Generated by: {RID}\n")
    md.append(f"- Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
    md.append("## Anchor (mtime-based)\n")
    md.append(f"- Anchor Runner: **R{anchor_id:04d}**\n")
    md.append(f"- Anchor mtime: **{fmt_dt(newest.mtime)}**\n\n")
    md.append("## Regeln\n")
    md.append("- Es zählen **nur Dateien direkt in `tools\\`** (ROOT). Unterordner werden ignoriert.\n")
    md.append("- Anchor wird **zeitbasiert** (mtime) ermittelt: neuester `.cmd` oder `.py` gewinnt.\n")
    md.append(f"- Sicherheits-Puffer: **die letzten {KEEP_LAST_N} Runner-Paare (mtime)** bleiben immer stehen.\n")
    md.append("- Zusätzlich: `registry\\tools_keep.txt` bleibt immer stehen.\n")
    md.append("- `.cmd` + `.py` gehören zusammen; wenn eins fehlt: **WARN**, Pair bleibt gültig.\n")
    md.append("- Archivieren bedeutet: wenn vorhanden, werden **beide** Dateien (cmd+py) verschoben.\n\n")

    md.append("## KEEP (Sicherheits-Puffer + tools_keep)\n")
    for rp in sorted(keep, key=lambda r: (r.mtime, r.rid), reverse=True):
        md.append(row(rp))

    md.append("\n## ARCHIVE\n")
    for rp in sorted(archive, key=lambda r: (r.mtime, r.rid), reverse=True):
        md.append(row(rp))

    PLAN_PATH.write_text("".join(md), encoding="utf-8", newline="\n")

    print(f"[{RID}] Anchor (mtime): R{anchor_id:04d} @ {fmt_dt(newest.mtime)}")
    print(f"[{RID}] KEEP (buffer+keepfile): {len(keep)} | ARCHIVE: {len(archive)} | Total pairs: {len(pairs)}")
    print(f"[{RID}] Plan: {PLAN_PATH}")

    report.append(f"Anchor: R{anchor_id:04d} @ {fmt_dt(newest.mtime)}")
    report.append(f"KEEP: {len(keep)}  ARCHIVE: {len(archive)}  Total pairs: {len(pairs)}")
    report.append(f"Plan: {PLAN_PATH}")
    report_path.write_text("\n".join(report) + "\n", encoding="utf-8")
    print(f"[{RID}] REPORT: {report_path}")
    print(f"[{RID}] DONE (Code 0)")
    return 0

if __name__ == "__main__":
    raise SystemExit(main())
